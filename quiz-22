/TITLE-Counting number of trailing zeroes in factorial of a number.
//Brute force------(can be optimized by divison of 5 algorithm)

#include <iostream>
#include <vector>
using namespace std;
//------------function to calculate number of trailing zeroes-----------
int trailing_zeroes(int n){ 
long long int fact=1;
int count=0;	
  for(int i=0;i<n;i++)
    {
	    fact=fact*(n-i);
	  }
long long int result;
result=fact;
  while (result % 10 ==0)
    {
	  result = result/10;
	  count++;
	  }
    return count;  
}


//----------------------for testing-------------------------


int main(){
int t;
cout << "2001\t" << "Donald Kuth\n" ;
cout << "No of test cases:";
cin >> t;
vector<int> testcases(t);
  for(int j=0; j<t; j++)
    {
	    cin >> testcases[j];
	  }
  for (int k=0; k<t; k++)
    {
	    cout << trailing_zeroes(testcases[k]) << "\n";
	  }
return 0;
}
/*----------------------READ ME-------------------------------
sorry but I like this algorithm!!
What are we doing?
We are first taking an input (say n) and then calculating "facotiral of n" viz n*(n-1)...3*2*1 (say fact). [NOT A CLEVER WAY BUT LET'S TRY]
Subsequently we are dividing computed value "fact" by 10 till it can be done so that we get number of trailing zeroes.
now on ecah division we have attached a counter which counts the number of zeroes (say count)
and we are done!!
(line-9) long long because computing factorial can blow up to huge numbers.
(line- 25) Search for "Donald Kuth" in the web.
 [PLEASE CHECK HOW THIS FAILS FOR INPUTS ABOVE 20]
*/
